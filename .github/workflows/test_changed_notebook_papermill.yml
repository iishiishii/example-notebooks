# This workflows executes new or modified example notebooks.

name: test_changed_notebooks_papermill

defaults:
  run:
    shell: bash  # To override PowerShell on Windows

on:
  # Trigger the workflow on push or PR to any branch
  push:
    paths:
      - '**/*.ipynb'
  pull_request:
    paths:
      - '**/*.ipynb'
    # don't trigger for draft PRs
    types: [ opened, synchronize, reopened, ready_for_review ]
  # Trigger the workflow on manual dispatch
  workflow_dispatch:

jobs:
  select-runner:
    runs-on: ubuntu-22.04
    outputs:
      runner: ${{ steps.select_runner.outputs.runner }}
    steps:
      - uses: actions/checkout@v4
      - name: Select runner
        id: select_runner
        run: |
          if [ "${{ github.repository }}" = "neurodesk/example-notebooks" ]; then
            echo "runner=self-hosted" >> $GITHUB_OUTPUT
          else
            echo "runner=ubuntu-22.04" >> $GITHUB_OUTPUT
          fi
          
  get-notebooks:
    runs-on: ubuntu-22.04
    outputs:
      notebook_list: ${{ steps.list_changed_notebooks.outputs.notebook_list }}
    steps:
    - uses: actions/checkout@v4
    - name: Find all notebooks with changes
      id: find_changed_notebooks
      uses: tj-actions/changed-files@v45.0.3
      with:
        path: "./books"
        files: |
          **/*.ipynb
          *.md
        dir_names_exclude_current_dir: "true"
    - name: Filter down to changed notebooks
      id: list_changed_notebooks
      run: |
        echo ${{ steps.find_changed_notebooks.outputs.all_changed_files }}
        changed_notebooks=$(echo "${{ steps.find_changed_notebooks.outputs.all_changed_files }}")
        
        notebook_list='['
        for NOTEBOOK in $(echo "${changed_notebooks}"); do
          notebook_list+="\"${NOTEBOOK}\","
        done
        notebook_list=$(sed '$s/,$//' <<< $notebook_list)
        notebook_list+=']'
        echo "notebook_list=${notebook_list}"
        echo "notebook_list=${notebook_list}" >> $GITHUB_OUTPUT

  test-notebooks:
    needs: [ select-runner, get-notebooks ]
    if: ${{ needs.get-notebooks.outputs.notebook_list != '[]' }}
    runs-on: ${{ needs.select-runner.outputs.runner }}
    strategy:
      fail-fast: false
      matrix:
        notebooks: ${{ fromJson(needs.get-notebooks.outputs.notebook_list) }}
    env:
      USER_TOKEN: ${{ secrets.JUPYTER_PLAY_AUS_TOKEN }}
      USER: "aaf__70rrujda5-_yveeucjlhxjz0rqohejq14uzf6hro04"
      API_URL: "https://play.neurodesk.cloud.edu.au"
      SERVER_NAME: "play-aus"

    steps:
    - uses: actions/checkout@v4
    
    - name: Install Required Tools
      run: |
        echo "Installing required tools..."
        sudo apt-get update
        sudo apt-get install -y jq
        wget -qO /tmp/websocat https://github.com/vi/websocat/releases/latest/download/websocat.x86_64-unknown-linux-musl
        sudo chmod +x /tmp/websocat
        sudo mv /tmp/websocat /usr/local/bin/websocat

    - name: Setup Configuration
      run: |
        echo "=== JupyterHub Notebook Testing Started ==="
        echo "Server: $SERVER_NAME"
        echo "User: $USER"
        echo "API URL: $API_URL"
        echo "Notebook: ${{ matrix.notebooks }}"
        echo "NOTEBOOK_NAME=$(basename ${{ matrix.notebooks }})" >> $GITHUB_ENV
        echo "Output: $NOTEBOOK_NAME_output.ipynb"
        echo "OUTPUT_NAME=$(basename -s .ipynb ${{ matrix.notebooks }})_output.ipynb" >> $GITHUB_ENV

    - name: Start JupyterHub Server
      run: |
        echo "=== Starting JupyterHub Server ==="
        
        # Check if server is already running and stop it
        echo "Checking if server is already running..."
        SERVER_STATUS=$(curl -s -k -H "Authorization: token $USER_TOKEN" $API_URL/hub/api/users/$USER 2>/dev/null || echo "{}")

        # Check if the token is valid
        if [[ "$SERVER_STATUS" == *"403"* ]]; then
          echo "‚ùå Authentication failed - 403 Forbidden. Check your API token."
          echo "Server response: $SERVER_STATUS"
          exit 1
        fi
        
        # Check if server is running (server is not null and ready is true)
        if [[ "$SERVER_STATUS" == *"\"server\": \"/user/$USER/\""* ]] && [[ "$SERVER_STATUS" == *"\"ready\": true"* ]]; then
          echo "Server is running, stopping it first..."
          curl -s -k -X DELETE -H "Authorization: token $USER_TOKEN" $API_URL/hub/api/users/$USER/server
          
          echo "Waiting for server to stop..."
          for i in {1..12}; do
            sleep 10
            STATUS=$(curl -s -k -H "Authorization: token $USER_TOKEN" $API_URL/hub/api/users/$USER 2>/dev/null || echo "{}")
            if [[ "$STATUS" == *"\"server\": null"* ]] && [[ "$STATUS" == *"\"pending\": null"* ]]; then
              echo "‚úÖ Server stopped successfully"
              break
            fi
            echo "Waiting for server to stop... (${i}0s elapsed)"
          done
        elif [[ "$SERVER_STATUS" == *"\"pending\": \"spawn\""* ]]; then
          echo "Server is already starting, waiting for it to complete..."
        else
          echo "Server is stopped, ready to start"
        fi
        
        # Start the server
        echo "Starting server for $USER..."
        START_RESPONSE=$(curl -s -k -X POST -H "Authorization: token $USER_TOKEN" $API_URL/hub/api/users/$USER/server || echo "Failed to start server")
        echo "Start server response: ${START_RESPONSE:0:100}..."
        
        # Wait for server to start
        echo "Waiting for server to start..."
        SERVER_STARTED=false
        
        for i in {1..24}; do
          sleep 10
          SERVER_STATUS=$(curl -s -k -H "Authorization: token $USER_TOKEN" $API_URL/hub/api/users/$USER 2>/dev/null || echo "{}")
          
          if [[ "$SERVER_STATUS" == *"\"server\": \"/user/$USER/\""* ]] && [[ "$SERVER_STATUS" == *"\"ready\": true"* ]] && [[ "$SERVER_STATUS" == *"\"pending\": null"* ]]; then
            echo "‚úÖ Server started successfully (${i}0s elapsed)"
            echo "Server status: ${SERVER_STATUS:0:150}..."
            SERVER_STARTED=true
            break
          elif [[ "$SERVER_STATUS" == *"\"pending\": \"spawn\""* ]]; then
            echo "Server is still starting... (${i}0s elapsed)"
          else
            echo "Waiting for server to start... (${i}0s elapsed)"
          fi
        done
        
        if [ "$SERVER_STARTED" != true ]; then
          echo "‚ùå Server failed to start within timeout"
          exit 1
        fi
        
        # Wait for server to fully initialize
        echo "Waiting for server to fully initialize..."
        sleep 15

    - name: Create and Execute $NOTEBOOK_NAME Notebook
      working-directory: ./books
      run: |
        set +e  # Don't exit on errors, we want to capture them

        echo "=== Creating and Executing $NOTEBOOK_NAME Notebook ==="
        
        # Create Notebook in the JupyterHub instance

        jq -n \
            --arg type "notebook" \
            --slurpfile content "${{ matrix.notebooks }}" \
            '{type: $type, content: $content[0]}' > payload.json

        echo "Payload for creating notebook:"
        cat payload.json

        CREATE_RESPONSE=$(curl -k -s -X PUT \
            -H "Authorization: token $USER_TOKEN" \
            -H "Content-Type: application/json" \
            --data-binary @payload.json \
            "$API_URL/user/$USER/api/contents/$NOTEBOOK_NAME")
        
        if echo "$CREATE_RESPONSE" | grep -q '"name"'; then
            echo "‚úÖ FSL Notebook created successfully"
        else
            echo "‚ùå Failed to create notebook"
            echo "Response: $CREATE_RESPONSE"
            exit 1
        fi
        
        # Create terminal session
        echo ""
        echo "üîç STEP 2: Create Terminal Session"
        echo "----------------------------------------"
        
        TERMINAL_RESPONSE=$(curl -k -s -X POST \
            -H "Authorization: token $USER_TOKEN" \
            "$API_URL/user/$USER/api/terminals")
        
        TERMINAL_NAME=$(echo "$TERMINAL_RESPONSE" | jq -r '.name')
        
        if [ -n "$TERMINAL_NAME" ] && [ "$TERMINAL_NAME" != "null" ]; then
            echo "‚úÖ Terminal created: $TERMINAL_NAME"
            sleep 5
        else
            echo "‚ùå Terminal creation failed"
            echo "Response: $TERMINAL_RESPONSE"
            exit 1
        fi
        
        # Setup WebSocket connection function
        clean_api_url=${API_URL#*//}
        WS_URL="ws://$clean_api_url/user/$USER/terminals/websocket/$TERMINAL_NAME"
        
        execute_command() {
            local cmd="$1"
            local timeout="${2:-30}"
            
            echo "Executing: $cmd"
            
            local output=$(echo "[\"stdin\", \"$cmd\\r\\n\"]" | \
                timeout $timeout websocat --text "$WS_URL" \
                -H "Authorization: token $USER_TOKEN" 2>/dev/null | \
                grep '^\["stdout"' | \
                head -20 | \
                sed 's/^\["stdout", *"//; s/"\]$//; s/\\r\\n/\n/g; s/\\n/\n/g' | \
                tr -d '\000-\037' || echo "")
            
            if [ -n "$output" ]; then
                echo "‚úÖ Command executed successfully"
                echo "Output: $output"
                return 0
            else
                echo "‚ùå Command failed or no output"
                return 1
            fi
        }
        
        # Install papermill
        echo ""
        echo "üîç STEP 3: Install papermill"
        echo "----------------------------------------"
        execute_command "pip install papermill"
        
        # Update kernel specification
        echo ""
        echo "üîç STEP 4: Update kernel specification"
        echo "----------------------------------------"
        KERNEL_CMD="python -c \"import nbformat; f = '$NOTEBOOK_NAME'; nb = nbformat.read(open(f), as_version=4); nb['metadata']['kernelspec']['name'] = 'python3'; nbformat.write(nb, open(f, 'w'))\""
        execute_command "$KERNEL_CMD"
        sleep 30
        # Execute notebook with papermill
        echo ""
        echo "üîç STEP 5: Execute notebook with papermill"
        echo "----------------------------------------"
        execute_command "papermill $NOTEBOOK_NAME $OUTPUT_NAME" 120
        sleep 60
        # Verify papermill completed
        echo "Checking if papermill completed successfully..."
        execute_command "echo 'Papermill exit code:' && echo $?" 5
        execute_command "wc -l $OUTPUT_NAME" 10
        
        # Export terminal name for cleanup
        echo "TERMINAL_NAME=$TERMINAL_NAME" >> $GITHUB_ENV

    - name: Check Notebook Execution Results
      run: |
        echo "=== Checking Notebook Execution Results ==="
        
        # Setup WebSocket connection function
        clean_api_url=${API_URL#*//}
        WS_URL="ws://$clean_api_url/user/$USER/terminals/websocket/$TERMINAL_NAME"
        
        execute_command() {
            local cmd="$1"
            local timeout="${2:-30}"
            
            echo "Executing: $cmd"
            
            local output=$(echo "[\"stdin\", \"$cmd\\r\\n\"]" | \
                timeout $timeout websocat --text "$WS_URL" \
                -H "Authorization: token $USER_TOKEN" 2>/dev/null | \
                grep '^\["stdout"' | \
                head -20 | \
                sed 's/^\["stdout", *"//; s/"\]$//; s/\\r\\n/\n/g; s/\\n/\n/g' | \
                tr -d '\000-\037' || echo "")
            
            if [ -n "$output" ]; then
                echo "‚úÖ Command executed successfully"
                echo "Output: $output"
                return 0
            else
                echo "‚ùå Command failed or no output"
                return 1
            fi
        }
        
        # Check if output file exists
        execute_command "ls -la $OUTPUT_NAME" 10
        
        # Check for success patterns
        SUCCESS_PATTERNS=(
            "FSL BET notebook execution completed successfully"
            "Brain extraction demo finished" 
            "All steps completed"
            "vendor_id"
            "model name"
            "Usage.*bet"
            "preCourse.tar.gz"
            "structural_brain"
        )
        
        echo "Checking for success patterns in output..."
        PATTERN_COUNT=0
        for pattern in "${SUCCESS_PATTERNS[@]}"; do
            if execute_command "grep -q '$pattern' $OUTPUT_NAME" 5; then
                echo "‚úÖ Found pattern: $pattern"
                PATTERN_COUNT=$((PATTERN_COUNT + 1))
            else
                echo "‚ùå Missing pattern: $pattern"
            fi
        done
        
        # Check for errors
        echo ""
        echo "Checking for errors..."
        ERROR_CHECK=$(execute_command "grep -i 'error\|exception\|failed' $OUTPUT_NAME || echo 'No errors found'" 10)
        
        if echo "$ERROR_CHECK" | grep -q "No errors found"; then
            echo "‚úÖ No obvious errors detected"
        else
            echo "‚ö†Ô∏è Potential errors found:"
            echo "$ERROR_CHECK"
        fi
        
        # Export results
        echo "PATTERN_COUNT=$PATTERN_COUNT" >> $GITHUB_ENV
        echo "SUCCESS_PATTERNS_TOTAL=8" >> $GITHUB_ENV
        
        if [ $PATTERN_COUNT -ge 5 ]; then
            echo "‚úÖ Notebook execution successful! ($PATTERN_COUNT/8 patterns found)"
            echo "NOTEBOOK_SUCCESS=true" >> $GITHUB_ENV
        else
            echo "‚ùå Notebook execution may have failed ($PATTERN_COUNT/8 patterns found)"
            echo "NOTEBOOK_SUCCESS=false" >> $GITHUB_ENV
        fi

    - name: Cleanup Notebook Files
      if: always()
      run: |
        echo "=== Cleaning up Notebook Files ==="
        
        # Setup WebSocket connection function
        clean_api_url=${API_URL#*//}
        WS_URL="ws://$clean_api_url/user/$USER/terminals/websocket/$TERMINAL_NAME"
        
        execute_command() {
            local cmd="$1"
            local timeout="${2:-30}"
            
            echo "Executing: $cmd"
            
            local output=$(echo "[\"stdin\", \"$cmd\\r\\n\"]" | \
                timeout $timeout websocat --text "$WS_URL" \
                -H "Authorization: token $USER_TOKEN" 2>/dev/null | \
                grep '^\["stdout"' | \
                head -20 | \
                sed 's/^\["stdout", *"//; s/"\]$//; s/\\r\\n/\n/g; s/\\n/\n/g' | \
                tr -d '\000-\037' || echo "")
            
            if [ -n "$output" ]; then
                echo "‚úÖ Command executed successfully"
                echo "Output: $output"
                return 0
            else
                echo "‚ùå Command failed or no output"
                return 1
            fi
        }
        
        # List files before cleanup
        echo "Files before cleanup:"
        execute_command "ls -la *.ipynb" 10
        
        # Remove notebook files via terminal
        echo ""
        echo "Removing notebook files..."
        execute_command "rm -f $NOTEBOOK_NAME $OUTPUT_NAME" 10
        
        # Verify files are removed
        echo ""
        echo "Verifying files are removed:"
        execute_command "ls -la *.ipynb || echo 'No notebook files found'" 10
        
        
        # Delete terminal session
        echo ""
        echo "Deleting terminal session..."
        curl -k -s -X DELETE \
            -H "Authorization: token $USER_TOKEN" \
            "$API_URL/user/$USER/api/terminals/$TERMINAL_NAME" || true
        
        echo "‚úÖ Cleanup completed"

    - name: Stop JupyterHub Server
      if: always()
      run: |
        echo "=== Stopping JupyterHub Server ==="
        
        # Stop the server
        echo "Stopping server..."
        curl -s -k -X DELETE -H "Authorization: token $USER_TOKEN" $API_URL/hub/api/users/$USER/server || true
        
        echo "Waiting for server to stop..."
        for i in {1..12}; do
          sleep 10
          STATUS=$(curl -s -k -H "Authorization: token $USER_TOKEN" $API_URL/hub/api/users/$USER 2>/dev/null || echo "{}")
          if [[ "$STATUS" != *"\"server\":"* ]]; then
            echo "‚úÖ Server stopped successfully"
            break
          fi
          echo "Waiting for server to stop... (${i}0s elapsed)"
        done
        
        echo "‚úÖ Server cleanup completed"

    - name: Generate Test Report
      if: always()
      run: |
        echo "=== Final Notebook Test Report ==="
        
        PATTERNS_FOUND=${PATTERN_COUNT:-0}
        PATTERNS_TOTAL=${SUCCESS_PATTERNS_TOTAL:-8}
        NOTEBOOK_STATUS=${NOTEBOOK_SUCCESS:-false}
        
        echo "Test Results Summary:"
        echo "- Server Management: ‚úÖ"
        echo "- Notebook Creation: ‚úÖ"
        echo "- Notebook Execution: $([ "$NOTEBOOK_STATUS" = "true" ] && echo "‚úÖ" || echo "‚ùå")"
        echo "- Success Patterns: $PATTERNS_FOUND/$PATTERNS_TOTAL $([ $PATTERNS_FOUND -ge 5 ] && echo "‚úÖ" || echo "‚ùå")"
        echo "- File Cleanup: ‚úÖ"
        echo "- Server Cleanup: ‚úÖ"
        
        echo ""
        echo "Notebook Test Details:"
        echo "- FSL Module Loading: $([ $PATTERNS_FOUND -ge 2 ] && echo "‚úÖ" || echo "‚ùå")"
        echo "- Course Data Download: $([ $PATTERNS_FOUND -ge 3 ] && echo "‚úÖ" || echo "‚ùå")"
        echo "- BET Execution: $([ $PATTERNS_FOUND -ge 4 ] && echo "‚úÖ" || echo "‚ùå")"
        echo "- Completion Markers: $([ $PATTERNS_FOUND -ge 5 ] && echo "‚úÖ" || echo "‚ùå")"
        
        if [ "$NOTEBOOK_STATUS" = "true" ] && [ $PATTERNS_FOUND -ge 5 ]; then
          echo ""
          echo "üéâ NOTEBOOK TEST PASSED!"
          echo "Server: ${{ matrix.server_name }}"
          echo "All critical components working correctly."
          exit 0
        else
          echo ""
          echo "‚ùå NOTEBOOK TEST FAILED!"
          echo "Server: ${{ matrix.server_name }}"
          echo "Check logs above for details."
          exit 1
        fi

    # Create issue only for play servers when they fail
    - name: Generate issue on job failure
      if: always() && failure() && contains(fromJSON('[ "play-aus"]'), matrix.server_name)
      uses: JasonEtco/create-an-issue@1b14a70e4d8dc185e5cc76d3bec9eab20257b2c5
      env: 
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        GITHUB_WORKFLOW: ${{ github.workflow }}
        GITHUB_SERVER_URL: ${{ github.server_url }}
        GITHUB_REPOSITORY: ${{ github.repository }}
        GITHUB_RUN_ID: ${{ github.run_id }}
        SERVER_NAME: ${{ matrix.server_name }}
        SERVER_URL: ${{ matrix.default_url }}
        PATTERNS_FOUND: ${{ env.PATTERN_COUNT }}
        NOTEBOOK_SUCCESS: ${{ env.NOTEBOOK_SUCCESS }}
      with:
        filename: .github/notebook_failure_issue_template.md


  build-structure:
    if: ${{ needs.test-notebooks.result != 'failure' }}
    needs: [ test-notebooks ]
    runs-on: ubuntu-22.04
    steps:
    - uses: actions/checkout@v4

    - name: Install dependencies
      shell: bash
      run: |
        python -m pip install --upgrade pip
        python -m pip install jupyter-book ghp-import 

    - name: Run all
      shell: bash
      working-directory: ./books
      env: 
        GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}
      run: |
        export PATH=$HOME/.local/bin:$PATH
        /bin/bash ../.github/scripts/write-toc-entry.sh
        sed -i 's/execute_notebooks: .*/execute_notebooks: off/' _config.yml
        cat _config.yml
        jb build .


    - name: Push to GitHub Pages
      uses: peaceiris/actions-gh-pages@v4.0.0
      if: github.event_name != 'pull_request'
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        publish_dir: ./books/_build/html
        keep_files: true
        cname: www.neurodesk.org
